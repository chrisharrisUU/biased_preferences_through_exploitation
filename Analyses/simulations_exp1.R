# Dependencies ------------------------------------------------------------

if (!require(needs)) {install.packages("needs"); library(needs)}
needs(dplyr, ggplot2, papaja, purrr, tidyr)


# Functions ---------------------------------------------------------------

sim <- new.env()

# BAYESIAN
sim$bayes_main <- function(subject,
                           nTrial = 84,
                           initevidence,
                           outcomeprob) {
  # Initialize parameters
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  ninev <- sum(initevidence)
  dp <- vector(mode = "integer", length = (ninev + nTrial))
  choice <- vector(mode = "integer", length = (ninev + nTrial))
  outcome <- vector(mode = "integer", length = (ninev + nTrial))
  # possible probabilities
  p <- seq(0, 1, .01)
  # prior_left <- rep(.5, length(ps))
  # prior_right <- rep(.5, length(ps))
  left <- right <- list(
    total = 0,
    wins = 0
  )
  
  # Initial evidence
  nleft <- sum(initevidence[c(1, 2)])
  nright <- sum(initevidence[c(3, 4)])
  inev <- tibble(choice = c(rep(1, nleft),
                            rep(2, nright)),
                 outcome = c(rep(1, initevidence[1]),
                             rep(0, initevidence[2]),
                             rep(1, initevidence[3]),
                             rep(0, initevidence[4])))
  inev <- inev[sample(nrow(inev)),]
  
  # Trials
  for (t in 1:ninev) {
    a_left <- 1 + left$wins
    b_left <- 1 + left$total - left$wins
    a_right <- 1 + right$wins
    b_right <- 1 + right$total - right$wins
    
    dp[t] <- a_right / (a_right + b_right) - a_left / (a_left + b_left)
    
    trialchoice <- unlist(inev[t, 1])
    trialoutcome <- unlist(inev[t, 2])
    
    if (trialchoice == 1) {
      left$total <- left$total + 1
      if (trialoutcome == 1) {
        left$wins <- left$wins + 1
      }
    } else {
      right$total <- right$total + 1
      if (trialoutcome == 1) {
        right$wins <- right$wins + 1
      }
    }
    # Save
    choice[t] <- trialchoice
    outcome[t] <- trialoutcome
  }
  
  for (t in (ninev + 1):(nTrial + ninev)) {
    a_left <- 1 + left$wins
    b_left <- 1 + left$total - left$wins
    a_right <- 1 + right$wins
    b_right <- 1 + right$total - right$wins
    
    q <- 3
    prob_left <- mean(sample(p, q, prob = dbeta(p, a_left, b_left)))
    prob_right <- mean(sample(p, q, prob = dbeta(p, a_right, b_right)))
    dp[t] <- prob_left - prob_right
    
    if (prob_left > prob_right) {
      trialchoice <- 1
      trialoutcome <- outcomes_left[t - ninev]
    } else {
      trialchoice <- 2
      trialoutcome <- outcomes_right[t - ninev]
    }
    
    if (trialchoice == 1) {
      left$total <- left$total + 1
      if (trialoutcome == 1) {
        left$wins <- left$wins + 1
      }
    } else {
      right$total <- right$total + 1
      if (trialoutcome == 1) {
        right$wins <- right$wins + 1
      }
    }
    # Save
    choice[t] <- trialchoice
    outcome[t] <- trialoutcome
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  tibble(choice, outcome, dp, id = rep(subject, ninev + nTrial)) %>%
    mutate(trial = 1:n())
}

bayes_sim <- function(n = 100,
                      nTrial = 84,
                      initevidence = c(9, 3 , 3, 1),
                      outcomeprob = .75) {
  # Set progres bar
  m <- n * (nTrial + sum(initevidence))
  assign("pb",
         txtProgressBar(min = 0, max = m, style = 3),
         envir = .GlobalEnv)
  
  # Get input
  subjects <- 1:n
  
  # Run per participant
  pout <- map(subjects, ~sim$bayes_main(.x, nTrial, initevidence, outcomeprob))
  # Adjust choiceindex
  pout <- map(pout, ~mutate(.x, choiceindex = ifelse(choice == 2, 0, 1)))
  # Return
  pout
}

bayes_sumdata <- function(input, participant = NA) {
  if (is.na(participant)) {
    # All participants
    data.frame(
      map(input, "choice") %>%
        as.data.frame() %>%
        transmute(choice = rowMeans(.)),
      map(input, "choiceindex") %>%
        as.data.frame() %>%
        transmute(choiceindex = rowMeans(.)),
      map(input, "outcome") %>%
        as.data.frame() %>%
        transmute(outcome = rowMeans(.)),
      map(input, "dp") %>%
        as.data.frame() %>%
        transmute(dp = rowMeans(.)),
      map(input, "trial") %>%
        as.data.frame() %>%
        transmute(trial = rowMeans(.))
    )
  } else {
    # Individual participant
    input[[participant]] %>%
      mutate(trial = 1:n())
  }
}

# BIAS
sim$bias_main <- function(noise = noise,
                      nTrial = nTrial,
                      outcomeprob = outcomeprob,
                      initevidence = initevidence,
                      subject) {
  # Prompts for left and right option
  prompt_left <- c(1, -1, 0, 0)
  prompt_right <- c(0, 0, 1, -1)
  
  # Matrix with outcomes
  outcome <- data.frame(left = rbinom(nTrial, 1, outcomeprob),
                        right = rbinom(nTrial, 1, outcomeprob))
  
  # Initial evidence
  ninev <- sum(initevidence)
  inev <- matrix(c(rep(c(1, -1, -1, -1), initevidence[1]),
                   rep(c(-1, 1, -1, -1), initevidence[2]),
                   rep(c(-1, -1, 1, -1), initevidence[3]),
                   rep(c(-1, -1, -1, 1), initevidence[4])),
                 ncol = 4, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial, ) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x))
  
  # Create dataframe
  results <- tibble(
    choice = c(rep(-1, sum(initevidence[1:2])),
               rep(1, sum(initevidence[3:4]))),
    outcome = c(rep(1, initevidence[1]),
                rep(0, initevidence[2]),
                rep(1, initevidence[3]),
                rep(0, initevidence[4]))
  ) %>%
    mutate(evidence = inev)
  results <- results[sample(nrow(results)),] %>%
    mutate(trial = 1:n())
  results <- results %>%
    mutate(left = (results %>%
                     split(.$trial) %>%
                     map_dbl(~sim$bias_match(unlist(.x$evidence), prompt_left))),
           right = (results %>%
                      split(.$trial) %>%
                      map_dbl(~sim$bias_match(unlist(.x$evidence), prompt_right)))) %>%
    mutate(cumleft = cumsum(left),
           cumright = cumsum(right))
  
  # Initialize remaining trials
  init <- tibble(trial = (1:nTrial) + ninev)
  results <- bind_rows(results, init)
  
  # Simulation
  for (t in (1 + ninev):(nTrial + ninev)) {
    # Get recent evidence
    colmn <- results$evidence[t - 1] %>% unlist
    
    # Calculate matches with respective prompts and update cumulative matches
    results$left[t] <- sim$bias_match(colmn, prompt_left)
    results$cumleft[t] <- results$cumleft[t - 1] + results$left[t]
    results$right[t] <- sim$bias_match(colmn, prompt_right)
    results$cumright[t] <- results$cumright[t - 1] + results$right[t]
    
    # Determine choice and outcome
    results$choice[t] <- ifelse(results$cumleft[t] > results$cumright[t], -1, 1)
    results$outcome[t] <- ifelse(results$choice[t] == -1,
                                 outcome[t - ninev, 1],
                                 outcome[t - ninev, 2])
    
    # Determine (idealized) experience
    if (results$choice[t] == -1) {
      if (results$outcome[t] == 1) {
        tmem <- c(1, -1, -1, -1)
      } else {
        tmem <- c(-1, 1, -1, -1)
      }
    } else {
      if (results$outcome[t] == 1) {
        tmem <- c(-1, -1, 1, -1)
      } else {
        tmem <- c(-1, -1, -1, 1)
      }
    }
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
    
    # Save as (noisy) memory
    results$evidence[t] <- list(tmem * sample(c(rep(-1, noise), rep(1, 4 - noise))))
  }
  
  # Return
  results
}

# Define matching function
sim$bias_match <- function(colmn, prompt) {
    tibble(prompt, colmn) %>%
      transmute(match = ifelse(prompt == colmn, 1, 0)) %>%
      sum
    
  }

bias_sim <- function(n = 100,
                     noise = 1,
                     nTrial = 84,
                     outcomeprob = .75,
                     initevidence = c(9, 3, 3, 1)) {
  # Set progress bar
  m <- n * (nTrial + sum(initevidence))
  assign("pb",
         txtProgressBar(min = 0, max = m, style = 3),
         envir = .GlobalEnv)
  
  # Run per participant
  pout <- map(1:n, ~sim$bias_main(noise, nTrial, outcomeprob, initevidence, .x))
  # Adjust choiceindex
  pout <- map(pout, ~mutate(.x, choiceindex = ifelse(choice == -1, 1, 0)))
  # Return
  pout
}

bias_sumdata <- function(input, participant = NA) {
  if (is.na(participant)) {
    # All participants
    data.frame(
      map(input, "choice") %>%
        as.data.frame() %>%
        transmute(choice = rowMeans(.)),
      map(input, "choiceindex") %>%
        as.data.frame() %>%
        transmute(choiceindex = rowMeans(.)),
      map(input, "cumleft") %>%
        as.data.frame() %>%
        transmute(cumleft = rowMeans(.)),
      map(input, "cumright") %>%
        as.data.frame() %>%
        transmute(cumright = rowMeans(.))
    ) %>%
      mutate(trial = 1:n())
  } else {
    # Individual participant
    input[[participant]] %>%
      mutate(trial = 1:n())
  }
}

# MINERVA-DM (MDM)
sim$mdm_main <- function(noise = noise,
                     nTrial = nTrial,
                     outcomeprob = outcomeprob,
                     initevidence = initevidence,
                     subject) {
  # Prompts for left and right option
  prompt_left <- c(1, -1, 0, 0)
  prompt_right <- c(0, 0, 1, -1)
  
  # Matrix with outcomes
  outcome <- data.frame(left = rbinom(nTrial, 1, outcomeprob),
                        right = rbinom(nTrial, 1, outcomeprob))
  
  # Initial evidence
  ninev <- sum(initevidence)
  inev <- matrix(c(rep(c(1, -1, -1, -1), initevidence[1]),
                   rep(c(-1, 1, -1, -1), initevidence[2]),
                   rep(c(-1, -1, 1, -1), initevidence[3]),
                   rep(c(-1, -1, -1, 1), initevidence[4])),
                 ncol = 4, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x))
  
  # Create dataframe
  results <- tibble(
    choice = c(rep(-1, sum(initevidence[1:2])),
               rep(1, sum(initevidence[3:4]))),
    outcome = c(rep(1, initevidence[1]),
                rep(0, initevidence[2]),
                rep(1, initevidence[3]),
                rep(0, initevidence[4]))
  ) %>%
    mutate(evidence = inev)
  results <- results[sample(nrow(results)),] %>%
    mutate(trial = 1:n())
  results <- results %>%
    mutate(left = (results %>%
                     split(.$trial) %>%
                     map_dbl(~sim$mdm_match(unlist(.x$evidence), prompt_left))),
           right = (results %>%
                      split(.$trial) %>%
                      map_dbl(~sim$mdm_match(unlist(.x$evidence), prompt_right)))) %>%
    # cumsum is equivalent to I (formula 3)
    mutate(cumleft = cumsum(left),
           cumright = cumsum(right))
  
  # Initialize remaining trials
  init <- tibble(trial = (1:nTrial) + ninev)
  results <- bind_rows(results, init)
  
  # Simulation
  for (t in (1 + ninev):(nTrial + ninev)) {
    # Get recent evidence
    colmn <- results$evidence[t - 1] %>% unlist
    
    # Calculate matches with respective prompts and update cumulative matches
    results$left[t] <- sim$mdm_match(colmn, prompt_left)
    results$cumleft[t] <- results$cumleft[t - 1] + results$left[t]
    results$right[t] <- sim$mdm_match(colmn, prompt_right)
    results$cumright[t] <- results$cumright[t - 1] + results$right[t]
    
    # Determine choice and outcome
    results$choice[t] <- ifelse(results$cumleft[t] > results$cumright[t], -1, 1)
    results$outcome[t] <- ifelse(results$choice[t] == -1,
                                 outcome[t - ninev, 1],
                                 outcome[t - ninev, 2])
    
    # Determine (idealized) experience
    if (results$choice[t] == -1) {
      if (results$outcome[t] == 1) {
        tmem <- c(1, -1, -1, -1)
      } else {
        tmem <- c(-1, 1, -1, -1)
      }
    } else {
      if (results$outcome[t] == 1) {
        tmem <- c(-1, -1, 1, -1)
      } else {
        tmem <- c(-1, -1, -1, 1)
      }
    }
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
    
    # Save as (noisy) memory (Learning parameter L)
    results$evidence[t] <- list(tmem * rbinom(4, 1, (1 - noise)))
  }
  
  # Return
  results
}

# Define matching function
sim$mdm_match <- function(prompt, colmn) {
  tibble(prompt, colmn) %>%
    transmute(match = ifelse(prompt == colmn, 1, 0),
              n = ifelse(prompt != 0 & colmn != 0, 1, 0)) %>%
    summarize(pt = sum(match),
              n = sum(n)) %>%
    summarize(s = ifelse(n != 0, pt/n, 0)) %>%
    summarize(a = s^3) %>%
    unlist()
}

mdm_sim <- function(n = 100,
                    noise = .25,
                    nTrial = 84,
                    outcomeprob = .75,
                    initevidence = c(9, 3, 3, 1)) {
  # Set progres bar
  m <- n * (nTrial + sum(initevidence))
  assign("pb",
         txtProgressBar(min = 0, max = m, style = 3),
         envir = .GlobalEnv)
  
  # Run per participant
  pout <- map(1:n, ~sim$mdm_main(noise, nTrial, outcomeprob, initevidence, .x))
  # Adjust choiceindex
  pout <- map(pout, ~mutate(.x, choiceindex = ifelse(choice == 1, 0, 1)))
  # Return
  pout
}

mdm_sumdata <- function(input, participant = NA) {
  if (is.na(participant)) {
    # All participants
    data.frame(
      map(input, "choice") %>%
        as.data.frame() %>%
        transmute(choice = rowMeans(.)),
      map(input, "choiceindex") %>%
        as.data.frame() %>%
        transmute(choiceindex = rowMeans(.)),
      map(input, "cumleft") %>%
        as.data.frame() %>%
        transmute(cumleft = rowMeans(.)),
      map(input, "cumright") %>%
        as.data.frame() %>%
        transmute(cumright = rowMeans(.))
    ) %>%
      mutate(trial = 1:n())
  } else {
    # Individual participant
    input[[participant]] %>%
      mutate(trial = 1:n())
  }
}

# Rescorla-Wagner
sim$rw_main <- function(simpars,
                    subject,
                    nTrial = 84,
                    initevidence,
                    outcomeprob) {
  # Get alpha and beta parameters
  alpha <- simpars[1]
  beta <- simpars[2]
  # Length of initial evidence
  ninev <- sum(initevidence)
  
  # Init expectations
  v <- rep(.5, 2)
  
  # # initiate output matrices
  # VV <- list(matrix(nrow = n,
  #                   ncol = nTrial),
  #            matrix(nrow = n,
  #                   ncol = nTrial))
  # PP <- matrix(nrow = n,
  #              ncol = nTrial)
  
  # Initial evidence
  nleft <- sum(initevidence[c(1, 2)])
  nright <- sum(initevidence[c(3, 4)])
  inev <- tibble(choice = c(rep(1, nleft),
                            rep(2, nright)),
                 outcome = c(rep(1, initevidence[1]),
                             rep(0, initevidence[2]),
                             rep(1, initevidence[3]),
                             rep(0, initevidence[4])))
  inev <- inev[sample(nrow(inev)),]
  
  # get the task information
  outcome <- data.frame(left = rbinom(nTrial, 1, outcomeprob),
                        right = rbinom(nTrial, 1, outcomeprob))
  nt <- nTrial + ninev
  nc <- 2
  
  # initialise choice and outcome vectors to store the data.
  loglik <- 0
  choice <- rep(NA, nt)
  VV <- matrix(nrow = nt,
               ncol = nc) # matrix to store value over trials
  PP <- matrix(nrow = nt,
               ncol = nc) # matrix to store choice probability over trials
  
  # Initial evidence
  for (t in 1:nrow(inev)) {
    # Compute likelihood of the each choice option 
    # exponentiate the value
    ev <- exp(beta * v)
    # compute the sum of the values
    sev <- sum(ev)
    # probability each choice i.e. ratio of each of the values and their sum. 
    # This code effectively does: 
    # p(1) = ev(1)/sev;
    # p(2) = ev(2)/sev;
    p <- ev/sev
    
    c <- unlist(inev[t, 1])
    r <- unlist(inev[t, 2])
    
    loglik <- loglik + log(p[c])
    
    # store value of V
    VV[t,] <- v
    PP[t,] <- p
    
    # compute prediction error
    dv <- r - v[c]
    # update value
    v[c] <- v[c] + alpha * dv
    
    # store choice
    choice[t] <- c
    
  }
  
  # Free sampling
  for (t in (ninev + 1):nt) {
    # Compute likelihood of the each choice option 
    # exponentiate the value
    ev <- exp(beta * v)
    # compute the sum of the values
    sev <- sum(ev)
    # probability each choice i.e. ratio of each of the values and their sum. 
    # This code effectively does: 
    # p(1) = ev(1)/sev;
    # p(2) = ev(2)/sev;
    p <- ev/sev
    
    # Do a weighted coinflip to make a choice: choose stim 1 if random
    # number is in the [0 p(1)] interval, and 2 otherwise
    if (runif(1) < p[1]) {
      c <- 1
    } else {
      c <- 2
    }
    # select the outcome for this choice
    r <- outcome[t - ninev, c]
    
    # update the log likelihood with the p(choice|model):
    # note that this line can be done more efficiently after the trial
    # loop, see below
    # alternative, more efficient way of computing the likelihood
    # loglik = sum(log(PP(c1,1)))+sum(log(PP(c2,2)));
    loglik <- loglik + log(p[c])
    
    # store value of V
    VV[t,] <- v
    PP[t,] <- p
    
    # compute prediction error
    dv <- r - v[c]
    # update value
    v[c] <- v[c] + alpha * dv
    
    # store choice
    choice[t] <- c
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  data.frame(choice,
             value_left = VV[,1],
             value_right = VV[,2],
             choiceprob_left = PP[,1],
             choiceprob_right = PP[,2],
             outprob = rep(outcomeprob, nt)) %>%
    mutate(trial = 1:n())
}
rw_sim <- function(n = 100,
                   alpha = .25,
                   beta = 1,
                   nTrial = 84,
                   initevidence = c(9, 3 , 3, 1),
                   outcomeprob = .75) {
  # Set progres bar
  m <- n * (nTrial + sum(initevidence))
  assign("pb",
         txtProgressBar(min = 0, max = m, style = 3),
         envir = .GlobalEnv)
  
  # Get input
  subjects <- 1:n
  simpars <- c(alpha, beta)
  names(simpars) <- c("alpha", "beta")
  
  # Run per participant
  pout <- map(subjects, ~sim$rw_main(simpars, .x, nTrial, initevidence, outcomeprob))
  # Adjust choiceindex
  pout <- map(pout, ~mutate(.x, choiceindex = ifelse(choice == 2, 0, 1)))
  # Return
  pout
}
rw_sumdata <- function(input, participant = NA) {
  if (is.na(participant)) {
    # All participants
    data.frame(
      map(input, "choice") %>%
        as.data.frame() %>%
        transmute(choice = rowMeans(.)),
      map(input, "choiceindex") %>%
        as.data.frame() %>%
        transmute(choiceindex = rowMeans(.)),
      map(input, "value_left") %>%
        as.data.frame() %>%
        transmute(value_left = rowMeans(.)),
      map(input, "value_right") %>%
        as.data.frame() %>%
        transmute(value_right = rowMeans(.)),
      map(input, "choiceprob_left") %>%
        as.data.frame() %>%
        transmute(choiceprob_left = rowMeans(.)),
      map(input, "choiceprob_right") %>%
        as.data.frame() %>%
        transmute(choiceprob_right = rowMeans(.)),
      map(input, "outprob") %>%
        as.data.frame() %>%
        transmute(outprob = rowMeans(.)),
      map(input, "trial") %>%
        as.data.frame() %>%
        transmute(trial = rowMeans(.))
    ) %>%
      pivot_longer(cols = c(value_left, value_right),
                   names_to = "bandit",
                   values_to = "value")
  } else {
    # Individual participant
    input[[participant]] %>%
      mutate(trial = 1:n()) %>%
      pivot_longer(cols = c(value_left, value_right),
                   names_to = "bandit",
                   values_to = "value")
  }
}

# Graph wrapper
draw <- function(rich, imp) {
  bind_rows(rich %>%
              mutate(condition = "rich"),
            imp %>%
              mutate(condition = "impoverished")) %>%
    mutate(condition = factor(condition, levels = c("rich", "impoverished"))) %>%
    ggplot() +
    geom_line(aes(x = trial, y = choiceindex, color = condition)) +
    geom_hline(aes(yintercept = .5), linetype = 3) +
    scale_color_brewer(palette = "Dark2") +
    theme_apa()
}


# Simulations -------------------------------------------------------------

results <- new.env()

# BAYESIAN
results$bayes_rich <- bayes_sim(n = 10000, initevidence = c(9, 3, 3, 1), outcomeprob = .75) %>% bayes_sumdata()
results$bayes_imp  <- bayes_sim(n = 10000, initevidence = c(3, 9, 1, 3), outcomeprob = .25) %>% bayes_sumdata()
draw(results$bayes_rich, results$bayes_imp)
ggsave("Output/Graphs/sim_bayes.svg", device = "svg")

results$bayes_r4   <- bayes_sim(n = 10000, initevidence = c(4, 4, 4, 4), outcomeprob = .75) %>% bayes_sumdata()
results$bayes_i4   <- bayes_sim(n = 10000, initevidence = c(4, 4, 4, 4), outcomeprob = .25) %>% bayes_sumdata()
draw(results$bayes_r4, results$bayes_i4)
ggsave("Output/Graphs/sim_bayes_4s.svg", device = "svg")

results$bayes_r50  <- bayes_sim(n = 10000, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% bayes_sumdata()
results$bayes_i50  <- bayes_sim(n = 10000, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% bayes_sumdata()
draw(results$bayes_r50, results$bayes_i50)
ggsave("Output/Graphs/sim_bayes_50.svg", device = "svg")

# BIAS
results$bias_rich <- bias_sim(n = 10000, initevidence = c(9, 3, 3, 1), outcomeprob = .75) %>% bias_sumdata()
results$bias_imp  <- bias_sim(n = 10000, initevidence = c(3, 9, 1, 3), outcomeprob = .25) %>% bias_sumdata()
draw(results$bias_rich, results$bias_imp)
ggsave("Output/Graphs/sim_bias.svg", device = "svg")

results$bias_r4   <- bias_sim(n = 10000, initevidence = c(4, 4, 4, 4), outcomeprob = .75) %>% bias_sumdata()
results$bias_i4   <- bias_sim(n = 10000, initevidence = c(4, 4, 4, 4), outcomeprob = .25) %>% bias_sumdata()
draw(results$bias_r4, results$bias_i4)
ggsave("Output/Graphs/sim_bias_4s.svg", device = "svg")

results$bias_r50  <- bias_sim(n = 10000, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% bias_sumdata()
results$bias_i50  <- bias_sim(n = 10000, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% bias_sumdata()
draw(results$bias_r50, results$bias_i50)
ggsave("Output/Graphs/sim_bias_50.svg", device = "svg")

# MDM
mdm_rich <- mdm_sim(n = 10000, initevidence = c(9, 3, 3, 1), outcomeprob = .75) %>% mdm_sumdata()
mdm_imp  <- mdm_sim(n = 10000, initevidence = c(3, 9, 1, 3), outcomeprob = .25) %>% mdm_sumdata()
draw(mdm_rich, mdm_imp)
ggsave("Output/Graphs/sim_mdm.svg", device = "svg")

results$mdm_r4   <- mdm_sim(n = 10000, initevidence = c(4, 4, 4, 4), outcomeprob = .75) %>% mdm_sumdata()
results$mdm_i4   <- mdm_sim(n = 10000, initevidence = c(4, 4, 4, 4), outcomeprob = .25) %>% mdm_sumdata()
draw(results$mdm_r4, results$mdm_i4)
ggsave("Output/Graphs/sim_mdm_4s.svg", device = "svg")

results$mdm_r50  <- mdm_sim(n = 10000, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% mdm_sumdata()
results$mdm_i50  <- mdm_sim(n = 10000, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% mdm_sumdata()
draw(results$mdm_r50, results$mdm_i50)
ggsave("Output/Graphs/sim_mdm_50.svg", device = "svg")

# Rescorla-Wagner
results$rw_rich <- rw_sim(n = 10000, initevidence = c(9, 3, 3, 1), outcomeprob = .75) %>% rw_sumdata()
results$rw_imp  <- rw_sim(n = 10000, initevidence = c(3, 9, 1, 3), outcomeprob = .25) %>% rw_sumdata()
draw(results$rw_rich, results$rw_imp)
ggsave("Output/Graphs/sim_rw.svg", device = "svg")

results$rw_r4   <- rw_sim(n = 10000, initevidence = c(4, 4, 4, 4), outcomeprob = .75) %>% rw_sumdata()
results$rw_i4   <- rw_sim(n = 10000, initevidence = c(4, 4, 4, 4), outcomeprob = .25) %>% rw_sumdata()
draw(results$rw_r4, results$rw_i4)
ggsave("Output/Graphs/sim_rw_4s.svg", device = "svg")

results$rw_r50  <- rw_sim(n = 10000, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% rw_sumdata()
results$rw_i50  <- rw_sim(n = 10000, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% rw_sumdata()
draw(results$rw_r50, results$rw_i50)
ggsave("Output/Graphs/sim_rw_50.svg", device = "svg")