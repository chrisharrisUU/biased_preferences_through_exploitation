# Dependencies ------------------------------------------------------------

if (!require(needs)) {install.packages("needs"); library(needs)}
needs(dplyr, ggplot2, gridExtra, papaja, purrr, tidyr)


# Functions ---------------------------------------------------------------

# Save functions in environment
sim <- new.env()

### BAYESIAN----
# Main simulation
sim$bayes_main <- function(subject,
                           nTrial,
                           initevidence,
                           outcomeprob,
                           q) {
  # Initialize parameters
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  ninev <- sum(initevidence)
  dp <- vector(mode = "integer", length = (ninev + nTrial))
  choice <- vector(mode = "integer", length = (ninev + nTrial))
  outcome <- vector(mode = "integer", length = (ninev + nTrial))
  # possible probabilities
  p <- seq(0, 1, .01)
  # prior_left <- rep(.5, length(ps))
  # prior_right <- rep(.5, length(ps))
  left <- right <- list(
    total = 0,
    wins = 0
  )
  
  # Initial evidence
  nleft <- sum(initevidence[c(1, 2)])
  nright <- sum(initevidence[c(3, 4)])
  inev <- tibble(choice = c(rep(1, nleft),
                            rep(2, nright)),
                 outcome = c(rep(1, initevidence[1]),
                             rep(0, initevidence[2]),
                             rep(1, initevidence[3]),
                             rep(0, initevidence[4])))
  inev <- inev[sample(nrow(inev)),]
  
  # Trials
  for (t in 1:ninev) {
    a_left <- 1 + left$wins
    b_left <- 1 + left$total - left$wins
    a_right <- 1 + right$wins
    b_right <- 1 + right$total - right$wins
    
    dp[t] <- a_right / (a_right + b_right) - a_left / (a_left + b_left)
    
    trialchoice <- unlist(inev[t, 1])
    trialoutcome <- unlist(inev[t, 2])
    
    if (trialchoice == 1) {
      left$total <- left$total + 1
      if (trialoutcome == 1) {
        left$wins <- left$wins + 1
      }
    } else {
      right$total <- right$total + 1
      if (trialoutcome == 1) {
        right$wins <- right$wins + 1
      }
    }
    # Save
    choice[t] <- trialchoice
    outcome[t] <- trialoutcome
  }
  
  for (t in (ninev + 1):(nTrial + ninev)) {
    a_left <- 1 + left$wins
    b_left <- 1 + left$total - left$wins
    a_right <- 1 + right$wins
    b_right <- 1 + right$total - right$wins
    
    prob_left <- mean(sample(p, q, prob = dbeta(p, a_left, b_left)))
    prob_right <- mean(sample(p, q, prob = dbeta(p, a_right, b_right)))
    dp[t] <- prob_left - prob_right
    
    if (prob_left > prob_right) {
      trialchoice <- 1
      trialoutcome <- outcomes_left[t - ninev]
    } else {
      trialchoice <- 2
      trialoutcome <- outcomes_right[t - ninev]
    }
    
    if (trialchoice == 1) {
      left$total <- left$total + 1
      if (trialoutcome == 1) {
        left$wins <- left$wins + 1
      }
    } else {
      right$total <- right$total + 1
      if (trialoutcome == 1) {
        right$wins <- right$wins + 1
      }
    }
    # Save
    choice[t] <- trialchoice
    outcome[t] <- trialoutcome
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  tibble(choice, outcome, dp, id = rep(subject, ninev + nTrial)) %>%
    mutate(trial = 1:n())
}

sim$bayes_main_loss <- function(subject,
                                nTrial,
                                initevidence,
                                outcomeprob,
                                q) {
  # Initialize parameters
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  ninev <- sum(initevidence)
  dp <- vector(mode = "integer", length = (ninev + nTrial))
  choice <- vector(mode = "integer", length = (ninev + nTrial))
  outcome <- vector(mode = "integer", length = (ninev + nTrial))
  # possible probabilities
  p <- seq(0, 1, .01)
  # prior_left <- rep(.5, length(ps))
  # prior_right <- rep(.5, length(ps))
  left <- right <- list(
    total = 0,
    wins = 0
  )
  
  # Initial evidence
  nleft <- sum(initevidence[c(1, 2)])
  nright <- sum(initevidence[c(3, 4)])
  inev <- tibble(choice = c(rep(1, nleft),
                            rep(2, nright)),
                 outcome = c(rep(1, initevidence[1]),
                             rep(0, initevidence[2]),
                             rep(1, initevidence[3]),
                             rep(0, initevidence[4])))
  inev <- inev[sample(nrow(inev)),]
  
  # Trials
  for (t in 1:ninev) {
    a_left <- 1 + left$total - left$wins
    b_left <- 1 + left$wins
    a_right <- 1 + right$total - right$wins
    b_right <- 1 + right$wins
    
    # dp[t] <- a_right / (a_right + b_right) - a_left / (a_left + b_left)
    
    trialchoice <- unlist(inev[t, 1])
    trialoutcome <- unlist(inev[t, 2])
    
    if (trialchoice == 1) {
      left$total <- left$total + 1
      if (trialoutcome == 1) {
        left$wins <- left$wins + 1
      }
    } else {
      right$total <- right$total + 1
      if (trialoutcome == 1) {
        right$wins <- right$wins + 1
      }
    }
    # Save
    choice[t] <- trialchoice
    outcome[t] <- trialoutcome
  }
  
  for (t in (ninev + 1):(nTrial + ninev)) {
    a_left <- 1 + left$total - left$wins
    b_left <- 1 + left$wins
    a_right <- 1 + right$total - right$wins
    b_right <- 1 + right$wins
    
    prob_left <- mean(sample(p, q, prob = dbeta(p, a_left, b_left)))
    prob_right <- mean(sample(p, q, prob = dbeta(p, a_right, b_right)))
    # dp[t] <- prob_left - prob_right
    
    if (prob_left < prob_right) {
      trialchoice <- 1
      trialoutcome <- outcomes_left[t - ninev]
    } else {
      trialchoice <- 2
      trialoutcome <- outcomes_right[t - ninev]
    }
    
    if (trialchoice == 1) {
      left$total <- left$total + 1
      if (trialoutcome == 1) {
        left$wins <- left$wins + 1
      }
    } else {
      right$total <- right$total + 1
      if (trialoutcome == 1) {
        right$wins <- right$wins + 1
      }
    }
    # Save
    choice[t] <- trialchoice
    outcome[t] <- trialoutcome
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  tibble(choice, outcome, dp, id = rep(subject, ninev + nTrial)) %>%
    mutate(trial = 1:n())
}

# Simulation handler
bayes_sim <- function(n = 100,
                      nTrial = 84,
                      initevidence = c(9, 3 , 3, 1),
                      outcomeprob = .75,
                      q = 1) {
  # Set progres bar
  m <- n * (nTrial + sum(initevidence))
  assign("pb",
         txtProgressBar(min = 0, max = m, style = 3),
         envir = .GlobalEnv)
  
  # Get input
  subjects <- 1:n
  
  # Run per participant
  pout <- map(subjects, ~sim$bayes_main(.x, nTrial, initevidence, outcomeprob, q))
  # Adjust choiceindex
  pout <- map(pout, ~mutate(.x, choiceindex = ifelse(choice == 2, 0, 1)))
  # Return
  pout
}

# Summarizes results
bayes_sumdata <- function(input, participant = NA) {
  if (is.na(participant)) {
    # All participants
    data.frame(
      map(input, "choice") %>%
        as.data.frame() %>%
        transmute(choice = rowMeans(.)),
      map(input, "choiceindex") %>%
        as.data.frame() %>%
        transmute(choiceindex = rowMeans(.)),
      map(input, "outcome") %>%
        as.data.frame() %>%
        transmute(outcome = rowMeans(.)),
      map(input, "dp") %>%
        as.data.frame() %>%
        transmute(dp = rowMeans(.)),
      map(input, "trial") %>%
        as.data.frame() %>%
        transmute(trial = rowMeans(.))
    )
  } else {
    # Individual participant
    input[[participant]] %>%
      mutate(trial = 1:n())
  }
}

### BIAS----
sim$bias_main <- function(noise, nTrial, outcomeprob, initevidence, subject, l, e) {
  # New definitions
  # l <- 9 # Length of vectors
  # e <- 5 # Number of switches (similarity between vectors)
  
  # Define ideal vectors
  left <- rbinom(l, 1, .5)
  right <- abs(left - sample(c(rep(1, e), rep(0, l - e))))
  
  if (sum(right) == 0) {
    right <- right + sample(c(1, rep(0, l - 1)))
  }
  if (sum(right) == 9) {
    right <- right - sample(c(1, rep(0, l - 1)))
  }
  
  if (sum(left) == 0) {
    left <- left + sample(c(1, rep(0, l - 1)))
  }
  if (sum(left) == 9) {
    left <- left - sample(c(1, rep(0, l - 1)))
  }
  
  win <- rbinom(l, 1, .5)
  loss <- abs(win - sample(c(rep(1, e), rep(0, l - e))))
  
  if (sum(loss) == 0) {
    loss <- loss + sample(c(1, rep(0, l - 1)))
  }
  if (sum(loss) == 9) {
    loss <- loss - sample(c(1, rep(0, l - 1)))
  }
  
  if (sum(win) == 0) {
    win <- win + sample(c(1, rep(0, l - 1)))
  }
  if (sum(win) == 9) {
    win <- win - sample(c(1, rep(0, l - 1)))
  }
  
  # Matrix with outcomes
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  
  # Initial evidence
  ninev <- sum(initevidence)
  
  # Init options
  inev_opt <- matrix(c(rep(left, initevidence[1]),
                       rep(left, initevidence[2]),
                       rep(right, initevidence[3]),
                       rep(right, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise))) # Add noise
  
  check <- unname(which(map_dbl(inev_opt, ~sum(unlist(.x))) == 0))
  for (i in check) {
    inev_opt[[i]] <- inev_opt[[i]] + sample(c(1, rep(0, l - 1)))
  }
  check <- unname(which(map_dbl(inev_opt, ~sum(unlist(.x))) == 9))
  for (i in check) {
    inev_opt[[i]] <- inev_opt[[i]] - sample(c(1, rep(0, l - 1)))
  }
  
  # Init outcomes
  inev_out <- matrix(c(rep(win, initevidence[1]),
                       rep(loss, initevidence[2]),
                       rep(win, initevidence[3]),
                       rep(loss, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise))) # Add noise
  
  check <- unname(which(map_dbl(inev_out, ~sum(unlist(.x))) == 0))
  for (i in check) {
    inev_out[[i]] <- inev_out[[i]] + sample(c(1, rep(0, l - 1)))
  }
  check <- unname(which(map_dbl(inev_out, ~sum(unlist(.x))) == 9))
  for (i in check) {
    inev_out[[i]] <- inev_out[[i]] - sample(c(1, rep(0, l - 1)))
  }
  
  # Create dataframe
  results <- tibble(
    choice = c(rep(-1, sum(initevidence[1:2])),
               rep(1, sum(initevidence[3:4]))),
    outcome = c(rep(1, initevidence[1]),
                rep(0, initevidence[2]),
                rep(1, initevidence[3]),
                rep(0, initevidence[4]))
  ) %>%
    # (V)ector for option and outcome
    mutate(vopt = inev_opt,
           vout = inev_out)
  results <- results[sample(nrow(results)),] %>%
    mutate(trial = 1:n())
  results <- results %>%
    # (W)eight for left and right option
    mutate(wleft = map_dbl(vopt, ~cor(unlist(.x), left, method = "spearman")), # map_dbl(vopt, ~crossprod(unlist(.x), left)) # map_dbl(vopt, ~sum(unlist(.x) == left))
           wright = map_dbl(vopt, ~cor(unlist(.x), right, method = "spearman"))) %>% # map_dbl(vopt, (~crossprod(unlist(.x), right))) # map_dbl(vopt, ~sum(unlist(.x) == right))
    # Correlations
    mutate(corwin = map_dbl(vout, ~cor(unlist(.x), win, method = "spearman")),
           corloss = map_dbl(vout, ~cor(unlist(.x), loss, method = "spearman"))) %>%
    # (W)eight for winning
    mutate(wwin = ifelse((corwin + corloss) == 0, 0, corwin / (corwin + corloss))
           # map_dbl(vout, ~sum(unlist(.x) == win))) %>%
    ) %>%
    # (M)atch for left and right
    mutate(mleft = wleft * wwin,
           mright = wright * wwin) %>%
    mutate(cumleft = cumsum(mleft),
           cumright = cumsum(mright))
  
  # Initialize remaining trials
  init <- tibble(trial = (1:nTrial) + ninev)
  results <- bind_rows(results, init)
  
  # Simulation
  for (t in (1 + ninev):(nTrial + ninev)) {
    # Option chosen
    if (results$cumleft[t - 1] > results$cumright[t - 1]) {
      results$choice[t] <- -1
      results$vopt[t] <- list(abs(left - rbinom(l, 1, noise)))
      results$outcome[t] <-  outcomes_left[t - ninev]
    } else if (results$cumleft[t - 1] < results$cumright[t - 1]) {
      results$choice[t] <- 1
      results$vopt[t] <- list(abs(right - rbinom(l, 1, noise)))
      results$outcome[t] <-  outcomes_right[t - ninev]
    } else {
      results$choice[t] <- ifelse(rbinom(1, 1, .5) == 1, 1, -1)
      results$vopt[t] <- ifelse(results$choice[t] < 0,
                                list(abs(left - rbinom(l, 1, noise))),
                                list(abs(right - rbinom(l, 1, noise))))
      results$outcome[t] <-  outcomes_right[t - ninev]
    }
    
    # Outcome chosen
    if (results$outcome[t] > 1) {
      results$vout[t] <- list(abs(win - rbinom(l, 1, noise)))
    } else {
      results$vout[t] <- list(abs(loss - rbinom(l, 1, noise)))
    }
    if (sum(unlist(results$vopt[t])) == 0) {
      results$vopt[[t]] <- results$vopt[[t]] + sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vopt[t])) == l) {
      results$vopt[[t]] <- results$vopt[[t]] - sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vout[t])) == 0) {
      results$vout[[t]] <- results$vout[[t]] + sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vout[t])) == l) {
      results$vout[[t]] <- results$vout[[t]] - sample(c(1, rep(0, l - 1)))
    }
    
    # Update weights, matches, and cumulative matching
    results$wleft[t] <- cor(unlist(results$vopt[t]), left, method = "spearman") # crossprod(unlist(results$vopt[t]), left) # sum(unlist(results$vopt[t]) == left)
    results$wright[t] <- cor(unlist(results$vopt[t]), right, method = "spearman") # crossprod(unlist(results$vopt[t]), right) # sum(unlist(results$vopt[t]) == right)
    results$corwin[t] <- cor(unlist(results$vout[t]), win, method = "spearman") # crossprod(unlist(results$vout[t]), win) # sum(unlist(results$vout[t]) == win)
    
    results$corloss[t] <- cor(unlist(results$vout[t]), loss, method = "spearman")
    results$wwin[t] <- ifelse((results$corwin[t] + results$corloss[t]) == 0, 0, results$corwin[t] / (results$corwin[t] + results$corloss[t]))
    
    results$mleft[t] <- results$wleft[t] * results$wwin[t]
    results$mright[t] <- results$wright[t] * results$wwin[t]
    results$cumleft[t] <- results$mleft[t] + results$cumleft[t - 1]
    results$cumright[t] <- results$mright[t] + results$cumright[t - 1]
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  results
}

sim$bias_main_loss <- function(noise, nTrial, outcomeprob, initevidence, subject, l, e) {
  # New definitions
  # l <- 9 # Length of vectors
  # e <- 5 # Number of switches (similarity between vectors)
  
  # Define ideal vectors
  left <- rbinom(l, 1, .5)
  right <- abs(left - sample(c(rep(1, e), rep(0, l - e))))
  
  if (sum(right) == 0) {
    right <- right + sample(c(1, rep(0, l - 1)))
  }
  if (sum(right) == 9) {
    right <- right - sample(c(1, rep(0, l - 1)))
  }
  
  if (sum(left) == 0) {
    left <- left + sample(c(1, rep(0, l - 1)))
  }
  if (sum(left) == 9) {
    left <- left - sample(c(1, rep(0, l - 1)))
  }
  
  win <- rbinom(l, 1, .5)
  loss <- abs(win - sample(c(rep(1, e), rep(0, l - e))))
  
  if (sum(loss) == 0) {
    loss <- loss + sample(c(1, rep(0, l - 1)))
  }
  if (sum(loss) == 9) {
    loss <- loss - sample(c(1, rep(0, l - 1)))
  }
  
  if (sum(win) == 0) {
    win <- win + sample(c(1, rep(0, l - 1)))
  }
  if (sum(win) == 9) {
    win <- win - sample(c(1, rep(0, l - 1)))
  }
  
  # Matrix with outcomes
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  
  # Initial evidence
  ninev <- sum(initevidence)
  
  # Init options
  inev_opt <- matrix(c(rep(left, initevidence[1]),
                       rep(left, initevidence[2]),
                       rep(right, initevidence[3]),
                       rep(right, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise))) # Add noise
  
  check <- unname(which(map_dbl(inev_opt, ~sum(unlist(.x))) == 0))
  for (i in check) {
    inev_opt[[i]] <- inev_opt[[i]] + sample(c(1, rep(0, l - 1)))
  }
  check <- unname(which(map_dbl(inev_opt, ~sum(unlist(.x))) == 9))
  for (i in check) {
    inev_opt[[i]] <- inev_opt[[i]] - sample(c(1, rep(0, l - 1)))
  }
  
  # Init outcomes
  inev_out <- matrix(c(rep(win, initevidence[1]),
                       rep(loss, initevidence[2]),
                       rep(win, initevidence[3]),
                       rep(loss, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise))) # Add noise
  
  check <- unname(which(map_dbl(inev_out, ~sum(unlist(.x))) == 0))
  for (i in check) {
    inev_out[[i]] <- inev_out[[i]] + sample(c(1, rep(0, l - 1)))
  }
  check <- unname(which(map_dbl(inev_out, ~sum(unlist(.x))) == 9))
  for (i in check) {
    inev_out[[i]] <- inev_out[[i]] - sample(c(1, rep(0, l - 1)))
  }
  
  # Create dataframe
  results <- tibble(
    choice = c(rep(-1, sum(initevidence[1:2])),
               rep(1, sum(initevidence[3:4]))),
    outcome = c(rep(1, initevidence[1]),
                rep(0, initevidence[2]),
                rep(1, initevidence[3]),
                rep(0, initevidence[4]))
  ) %>%
    # (V)ector for option and outcome
    mutate(vopt = inev_opt,
           vout = inev_out)
  results <- results[sample(nrow(results)),] %>%
    mutate(trial = 1:n())
  results <- results %>%
    # (W)eight for left and right option
    mutate(wleft = map_dbl(vopt, ~cor(unlist(.x), left, method = "spearman")), # map_dbl(vopt, ~crossprod(unlist(.x), left)) # map_dbl(vopt, ~sum(unlist(.x) == left))
           wright = map_dbl(vopt, ~cor(unlist(.x), right, method = "spearman"))) %>% # map_dbl(vopt, (~crossprod(unlist(.x), right))) # map_dbl(vopt, ~sum(unlist(.x) == right))
    # Correlations
    mutate(corwin = map_dbl(vout, ~cor(unlist(.x), win, method = "spearman")),
           corloss = map_dbl(vout, ~cor(unlist(.x), loss, method = "spearman"))) %>%
    # (W)eight for winning
    mutate(wwin = ifelse((corwin + corloss) == 0, 0, corloss / (corwin + corloss))
           # map_dbl(vout, ~sum(unlist(.x) == win))) %>%
    ) %>%
    # (M)atch for left and right
    mutate(mleft = wleft * wwin,
           mright = wright * wwin) %>%
    mutate(cumleft = cumsum(mleft),
           cumright = cumsum(mright))
  
  # Initialize remaining trials
  init <- tibble(trial = (1:nTrial) + ninev)
  results <- bind_rows(results, init)
  
  # Simulation
  for (t in (1 + ninev):(nTrial + ninev)) {
    # Option chosen
    if (results$cumleft[t - 1] < results$cumright[t - 1]) {
      results$choice[t] <- -1
      results$vopt[t] <- list(abs(left - rbinom(l, 1, noise)))
      results$outcome[t] <-  outcomes_left[t - ninev]
    } else if (results$cumleft[t - 1] > results$cumright[t - 1]) {
      results$choice[t] <- 1
      results$vopt[t] <- list(abs(right - rbinom(l, 1, noise)))
      results$outcome[t] <-  outcomes_right[t - ninev]
    } else {
      results$choice[t] <- ifelse(rbinom(1, 1, .5) == 1, 1, -1)
      results$vopt[t] <- ifelse(results$choice[t] < 0,
                                list(abs(left - rbinom(l, 1, noise))),
                                list(abs(right - rbinom(l, 1, noise))))
      results$outcome[t] <-  outcomes_right[t - ninev]
    }
    
    # Outcome chosen
    if (results$outcome[t] > 1) {
      results$vout[t] <- list(abs(win - rbinom(l, 1, noise)))
    } else {
      results$vout[t] <- list(abs(loss - rbinom(l, 1, noise)))
    }
    if (sum(unlist(results$vopt[t])) == 0) {
      results$vopt[[t]] <- results$vopt[[t]] + sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vopt[t])) == l) {
      results$vopt[[t]] <- results$vopt[[t]] - sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vout[t])) == 0) {
      results$vout[[t]] <- results$vout[[t]] + sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vout[t])) == l) {
      results$vout[[t]] <- results$vout[[t]] - sample(c(1, rep(0, l - 1)))
    }
    
    # Update weights, matches, and cumulative matching
    results$wleft[t] <- cor(unlist(results$vopt[t]), left, method = "spearman") # crossprod(unlist(results$vopt[t]), left) # sum(unlist(results$vopt[t]) == left)
    results$wright[t] <- cor(unlist(results$vopt[t]), right, method = "spearman") # crossprod(unlist(results$vopt[t]), right) # sum(unlist(results$vopt[t]) == right)
    results$corwin[t] <- cor(unlist(results$vout[t]), win, method = "spearman") # crossprod(unlist(results$vout[t]), win) # sum(unlist(results$vout[t]) == win)
    
    results$corloss[t] <- cor(unlist(results$vout[t]), loss, method = "spearman")
    results$wwin[t] <- ifelse((results$corwin[t] + results$corloss[t]) == 0, 0, results$corloss[t] / (results$corwin[t] + results$corloss[t]))
    
    results$mleft[t] <- results$wleft[t] * results$wwin[t]
    results$mright[t] <- results$wright[t] * results$wwin[t]
    results$cumleft[t] <- results$mleft[t] + results$cumleft[t - 1]
    results$cumright[t] <- results$mright[t] + results$cumright[t - 1]
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  results
}

sim$bias_main_freq <- function(noise, nTrial, outcomeprob, initevidence, subject, l, e) {
  # New definitions
  # l <- 9 # Length of vectors
  # e <- 5 # Number of switches (similarity between vectors)
  
  # Define ideal vectors
  left <- rbinom(l, 1, .5)
  right <- abs(left - sample(c(rep(1, e), rep(0, l - e))))
  
  if (sum(right) == 0) {
    right <- right + sample(c(1, rep(0, l - 1)))
  }
  if (sum(right) == 9) {
    right <- right - sample(c(1, rep(0, l - 1)))
  }
  
  if (sum(left) == 0) {
    left <- left + sample(c(1, rep(0, l - 1)))
  }
  if (sum(left) == 9) {
    left <- left - sample(c(1, rep(0, l - 1)))
  }
  
  win <- rbinom(l, 1, .5)
  loss <- abs(win - sample(c(rep(1, e), rep(0, l - e))))
  
  if (sum(loss) == 0) {
    loss <- loss + sample(c(1, rep(0, l - 1)))
  }
  if (sum(loss) == 9) {
    loss <- loss - sample(c(1, rep(0, l - 1)))
  }
  
  if (sum(win) == 0) {
    win <- win + sample(c(1, rep(0, l - 1)))
  }
  if (sum(win) == 9) {
    win <- win - sample(c(1, rep(0, l - 1)))
  }
  
  # Matrix with outcomes
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  
  # Initial evidence
  ninev <- sum(initevidence)
  
  # Init options
  inev_opt <- matrix(c(rep(left, initevidence[1]),
                       rep(left, initevidence[2]),
                       rep(right, initevidence[3]),
                       rep(right, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise))) # Add noise
  
  check <- unname(which(map_dbl(inev_opt, ~sum(unlist(.x))) == 0))
  for (i in check) {
    inev_opt[[i]] <- inev_opt[[i]] + sample(c(1, rep(0, l - 1)))
  }
  check <- unname(which(map_dbl(inev_opt, ~sum(unlist(.x))) == 9))
  for (i in check) {
    inev_opt[[i]] <- inev_opt[[i]] - sample(c(1, rep(0, l - 1)))
  }
  
  # Init outcomes
  inev_out <- matrix(c(rep(win, initevidence[1]),
                       rep(loss, initevidence[2]),
                       rep(win, initevidence[3]),
                       rep(loss, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise))) # Add noise
  
  check <- unname(which(map_dbl(inev_out, ~sum(unlist(.x))) == 0))
  for (i in check) {
    inev_out[[i]] <- inev_out[[i]] + sample(c(1, rep(0, l - 1)))
  }
  check <- unname(which(map_dbl(inev_out, ~sum(unlist(.x))) == 9))
  for (i in check) {
    inev_out[[i]] <- inev_out[[i]] - sample(c(1, rep(0, l - 1)))
  }
  
  # Create dataframe
  results <- tibble(
    choice = c(rep(-1, sum(initevidence[1:2])),
               rep(1, sum(initevidence[3:4]))),
    outcome = c(rep(1, initevidence[1]),
                rep(0, initevidence[2]),
                rep(1, initevidence[3]),
                rep(0, initevidence[4]))
  ) %>%
    # (V)ector for option and outcome
    mutate(vopt = inev_opt,
           vout = inev_out)
  results <- results[sample(nrow(results)),] %>%
    mutate(trial = 1:n())
  results <- results %>%
    # (W)eight for left and right option
    mutate(wleft = map_dbl(vopt, ~cor(unlist(.x), left, method = "spearman")), # map_dbl(vopt, ~crossprod(unlist(.x), left)) # map_dbl(vopt, ~sum(unlist(.x) == left))
           wright = map_dbl(vopt, ~cor(unlist(.x), right, method = "spearman"))) %>% # map_dbl(vopt, (~crossprod(unlist(.x), right))) # map_dbl(vopt, ~sum(unlist(.x) == right))
    # Correlations
    mutate(corwin = map_dbl(vout, ~cor(unlist(.x), win, method = "spearman")),
           corloss = map_dbl(vout, ~cor(unlist(.x), loss, method = "spearman"))) %>%
    # (W)eight for winning
    mutate(wwin = ifelse((corwin + corloss) == 0, 0, corloss / (corwin + corloss))
           # map_dbl(vout, ~sum(unlist(.x) == win))) %>%
    ) %>%
    # (M)atch for left and right
    mutate(mleft = wleft * wwin,
           mright = wright * wwin) %>%
    mutate(cumleft = cumsum(mleft),
           cumright = cumsum(mright)) %>%
    mutate(cumleft = -mleft,
           cumright = -mright)
  
  # Initialize remaining trials
  init <- tibble(trial = (1:nTrial) + ninev)
  results <- bind_rows(results, init)
  
  # Simulation
  for (t in (1 + ninev):(nTrial + ninev)) {
    # Option chosen
    if (results$cumleft[t - 1] > results$cumright[t - 1]) {
      results$choice[t] <- -1
      results$vopt[t] <- list(abs(left - rbinom(l, 1, noise)))
      results$outcome[t] <-  outcomes_left[t - ninev]
    } else if (results$cumleft[t - 1] < results$cumright[t - 1]) {
      results$choice[t] <- 1
      results$vopt[t] <- list(abs(right - rbinom(l, 1, noise)))
      results$outcome[t] <-  outcomes_right[t - ninev]
    } else {
      results$choice[t] <- ifelse(rbinom(1, 1, .5) == 1, 1, -1)
      results$vopt[t] <- ifelse(results$choice[t] < 0,
                                list(abs(left - rbinom(l, 1, noise))),
                                list(abs(right - rbinom(l, 1, noise))))
      results$outcome[t] <-  outcomes_right[t - ninev]
    }
    
    # Outcome chosen
    if (results$outcome[t] > 1) {
      results$vout[t] <- list(abs(win - rbinom(l, 1, noise)))
    } else {
      results$vout[t] <- list(abs(loss - rbinom(l, 1, noise)))
    }
    if (sum(unlist(results$vopt[t])) == 0) {
      results$vopt[[t]] <- results$vopt[[t]] + sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vopt[t])) == l) {
      results$vopt[[t]] <- results$vopt[[t]] - sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vout[t])) == 0) {
      results$vout[[t]] <- results$vout[[t]] + sample(c(1, rep(0, l - 1)))
    }
    if (sum(unlist(results$vout[t])) == l) {
      results$vout[[t]] <- results$vout[[t]] - sample(c(1, rep(0, l - 1)))
    }
    
    # Update weights, matches, and cumulative matching
    results$wleft[t] <- cor(unlist(results$vopt[t]), left, method = "spearman") # crossprod(unlist(results$vopt[t]), left) # sum(unlist(results$vopt[t]) == left)
    results$wright[t] <- cor(unlist(results$vopt[t]), right, method = "spearman") # crossprod(unlist(results$vopt[t]), right) # sum(unlist(results$vopt[t]) == right)
    results$corwin[t] <- cor(unlist(results$vout[t]), win, method = "spearman") # crossprod(unlist(results$vout[t]), win) # sum(unlist(results$vout[t]) == win)
    
    results$corloss[t] <- cor(unlist(results$vout[t]), loss, method = "spearman")
    results$wwin[t] <- ifelse((results$corwin[t] + results$corloss[t]) == 0, 0, results$corwin[t] / (results$corwin[t] + results$corloss[t]))
    
    results$mleft[t] <- results$wleft[t] * results$wwin[t]
    results$mright[t] <- results$wright[t] * results$wwin[t]
    results$cumleft[t] <- results$mleft[t] + results$cumleft[t - 1]
    results$cumright[t] <- results$mright[t] + results$cumright[t - 1]
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  results
}

# Define matching function
sim$bias_match <- function(colmn, prompt) {
  sum(prompt == colmn)
}

# Simulation handler
bias_sim <- function(n = 100,
                     noise = .33,
                     nTrial = 84,
                     outcomeprob = .75,
                     initevidence = c(9, 3, 3, 1),
                     l = 9,
                     e = 5) {
  # Set progress bar
  m <- n * (nTrial + sum(initevidence))
  assign("pb",
         txtProgressBar(min = 0, max = m, style = 3),
         envir = .GlobalEnv)
  
  # Run per participant
  pout <- map(1:n, ~sim$bias_main(noise = noise,
                                  nTrial = nTrial,
                                  outcomeprob = outcomeprob,
                                  initevidence = initevidence,
                                  subject = .x,
                                  l = l,
                                  e = e))
  # Adjust choiceindex
  pout <- map(pout, ~mutate(.x, choiceindex = ifelse(choice == -1, 1, 0)))
  # Return
  pout
}

# Summarizes results
bias_sumdata <- function(input, participant = NA) {
  if (is.na(participant)) {
    # All participants
    data.frame(
      map(input, "choice") %>%
        as.data.frame() %>%
        transmute(choice = rowMeans(.)),
      map(input, "choiceindex") %>%
        as.data.frame() %>%
        transmute(choiceindex = rowMeans(.)),
      map(input, "cumleft") %>%
        as.data.frame() %>%
        transmute(cumleft = rowMeans(.)),
      map(input, "cumright") %>%
        as.data.frame() %>%
        transmute(cumright = rowMeans(.))
    ) %>%
      mutate(trial = 1:n())
  } else {
    # Individual participant
    input[[participant]] %>%
      mutate(trial = 1:n())
  }
}

### MDM----
sim$mdm_main <- function(noise, nTrial, outcomeprob, initevidence, subject, l, e) {
  # define ideal vectors
  left <- sample(c(rep(c(-1, 0, 1), l / 3), rep(1, l %% 3)))
  change <- left + sample(c(rep(1, 2), rep(0, l - 2)))
  right <- ifelse(change == 2, -1, change)
  
  win <- sample(c(rep(c(-1, 0, 1), l / 3), rep(1, l %% 3)))
  change <- win + sample(c(rep(1, 5), rep(0, l - 5)))
  loss <- ifelse(change == 2, -1, change)
  
  # intensity criterion
  c <- .5
  
  # Matrix with outcomes
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  
  # Initial evidence
  ninev <- sum(initevidence)
  
  # Init options
  inev_opt <- matrix(c(rep(left, initevidence[1]),
                       rep(left, initevidence[2]),
                       rep(right, initevidence[3]),
                       rep(right, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise)))
  
  # Init outcomes
  inev_out <- matrix(c(rep(win, initevidence[1]),
                       rep(loss, initevidence[2]),
                       rep(win, initevidence[3]),
                       rep(loss, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise)))
  
  # Create dataframe
  results <- tibble(
    choice = c(rep(-1, sum(initevidence[1:2])),
               rep(1, sum(initevidence[3:4]))),
    outcome = c(rep(1, initevidence[1]),
                rep(0, initevidence[2]),
                rep(1, initevidence[3]),
                rep(0, initevidence[4]))
  ) %>%
    # (V)ector for option and outcome
    mutate(vopt = inev_opt,
           vout = inev_out)
  results <- results[sample(nrow(results)),] %>%
    mutate(trial = 1:n())
  results <- results %>%
    # Similarity
    mutate(win_s = map_dbl(vout, ~sim$match_s(unlist(.x), win))) %>%
    # Match with options IF similarity > .5
    mutate(left_s = ifelse(win_s >= c, map_dbl(vopt, ~sim$match_s(unlist(.x), left)), 0),
           right_s = ifelse(win_s >= c, map_dbl(vopt, ~sim$match_s(unlist(.x), right)), 0)) %>%
    # Determine number of traces > .5
    mutate(win_k = ifelse(win_s > c, 1, 0)) %>%
    mutate(win_k = cumsum(win_k)) %>%
    # Intensity: cubed similarity
    mutate(left = left_s ^ 3,
           right = right_s ^ 3) %>%
    # cumsum is equivalent to I (formula 3)
    mutate(cumleft = cumsum(left),
           cumright = cumsum(right))
  
  if (results$win_k[nrow(results)] == 0) {
    results$win_k[nrow(results)] <- 1
  }
  
  # Initialize remaining trials
  init <- tibble(trial = (1:nTrial) + ninev)
  results <- bind_rows(results, init)
  
  # Simulation
  for (t in (1 + ninev):(nTrial + ninev)) {
    # Option chosen
    if (results$cumleft[t - 1] / results$win_k[t - 1] > results$cumright[t - 1] / results$win_k[t - 1]) {
      results$choice[t] <- -1
      results$vopt[[t]] <- left * rbinom(l, 1, 1 - noise)
      results$outcome[t] <-  outcomes_left[t - ninev]
    } else if (results$cumleft[t - 1] < results$cumright[t - 1]) {
      results$choice[t] <- 1
      results$vopt[[t]] <- right * rbinom(l, 1, 1 - noise)
      results$outcome[t] <-  outcomes_right[t - ninev]
    } else {
      results$choice[t] <- ifelse(rbinom(1, 1, .5) == 1, 1, -1)
      results$vopt[[t]] <- ifelse(results$choice[t] < 0,
                                  left * rbinom(l, 1, 1 - noise),
                                  right * rbinom(l, 1, 1 - noise))
      results$outcome[t] <-  outcomes_right[t - ninev]
    }
    
    # Outcome chosen
    if (results$outcome[t] > 1) {
      results$vout[[t]] <- win * rbinom(l, 1, 1 - noise)
    } else {
      results$vout[[t]] <- loss * rbinom(l, 1, 1 - noise)
    }
    
    # Similarity
    results$win_s[t] <- sim$match_s(unlist(results$vout[t]), win)
    
    # Match with win IF similarity > .5
    results$left_s[t] <- ifelse(results$win_s[t] > c, sim$match_s(unlist(results$vopt[t]), left), 0)
    results$right_s[t] <- ifelse(results$win_s[t] > c, sim$match_s(unlist(results$vopt[t]), right), 0)
    
    # Update total number of traces > .5
    results$win_k[t] <- ifelse(results$win_s[t] > c, 1, 0) + results$win_k[t - 1]
    
    # Intensity: cubed similarity divided by number of traces
    results$left[t] <- results$left_s[t] ^ 3
    results$right[t] <- results$right_s[t] ^ 3
    
    # cumsum is equivalent to I (formula 3)
    results$cumleft[t] <- results$left[t] + results$cumleft[t - 1]
    results$cumright[t] <- results$right[t] + results$cumright[t - 1]
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  results
}

sim$mdm_main_loss <- function(noise, nTrial, outcomeprob, initevidence, subject, l, e) {
  # define ideal vectors
  left <- sample(c(rep(c(-1, 0, 1), l / 3), rep(1, l %% 3)))
  change <- left + sample(c(rep(1, 2), rep(0, l - 2)))
  right <- ifelse(change == 2, -1, change)
  
  win <- sample(c(rep(c(-1, 0, 1), l / 3), rep(1, l %% 3)))
  change <- win + sample(c(rep(1, 5), rep(0, l - 5)))
  loss <- ifelse(change == 2, -1, change)
  
  # intensity criterion
  c <- .5
  
  # Matrix with outcomes
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  
  # Initial evidence
  ninev <- sum(initevidence)
  
  # Init options
  inev_opt <- matrix(c(rep(left, initevidence[1]),
                       rep(left, initevidence[2]),
                       rep(right, initevidence[3]),
                       rep(right, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise)))
  
  # Init outcomes
  inev_out <- matrix(c(rep(win, initevidence[1]),
                       rep(loss, initevidence[2]),
                       rep(win, initevidence[3]),
                       rep(loss, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise)))
  
  # Create dataframe
  results <- tibble(
    choice = c(rep(-1, sum(initevidence[1:2])),
               rep(1, sum(initevidence[3:4]))),
    outcome = c(rep(1, initevidence[1]),
                rep(0, initevidence[2]),
                rep(1, initevidence[3]),
                rep(0, initevidence[4]))
  ) %>%
    # (V)ector for option and outcome
    mutate(vopt = inev_opt,
           vout = inev_out)
  results <- results[sample(nrow(results)),] %>%
    mutate(trial = 1:n())
  results <- results %>%
    # Similarity
    mutate(win_s = 0,
           loss_s = map_dbl(vout, ~sim$match_s(unlist(.x), loss))) %>%
    # Match with options IF similarity > .5
    mutate(left_s = ifelse(loss_s >= c, map_dbl(vopt, ~sim$match_s(unlist(.x), left)), 0),
           right_s = ifelse(loss_s >= c, map_dbl(vopt, ~sim$match_s(unlist(.x), right)), 0)) %>%
    # Determine number of traces > .5
    mutate(win_k = ifelse(win_s > c, 1, 0)) %>%
    mutate(win_k = cumsum(win_k)) %>%
    # Intensity: cubed similarity
    mutate(left = left_s ^ 3,
           right = right_s ^ 3) %>%
    # cumsum is equivalent to I (formula 3)
    mutate(cumleft = cumsum(left),
           cumright = cumsum(right)) %>%
    mutate(cumleft = -cumleft,
           cumright = -cumright)
  
  if (results$win_k[nrow(results)] == 0) {
    results$win_k[nrow(results)] <- 1
  }
  
  # Initialize remaining trials
  init <- tibble(trial = (1:nTrial) + ninev)
  results <- bind_rows(results, init)
  
  # Simulation
  for (t in (1 + ninev):(nTrial + ninev)) {
    # Option chosen
    if (results$cumleft[t - 1] / results$win_k[t - 1] > results$cumright[t - 1] / results$win_k[t - 1]) {
      results$choice[t] <- -1
      results$vopt[[t]] <- left * rbinom(l, 1, 1 - noise)
      results$outcome[t] <-  outcomes_left[t - ninev]
    } else if (results$cumleft[t - 1] < results$cumright[t - 1]) {
      results$choice[t] <- 1
      results$vopt[[t]] <- right * rbinom(l, 1, 1 - noise)
      results$outcome[t] <-  outcomes_right[t - ninev]
    } else {
      results$choice[t] <- ifelse(rbinom(1, 1, .5) == 1, 1, -1)
      results$vopt[[t]] <- ifelse(results$choice[t] < 0,
                                  left * rbinom(l, 1, 1 - noise),
                                  right * rbinom(l, 1, 1 - noise))
      results$outcome[t] <-  outcomes_right[t - ninev]
    }
    
    # Outcome chosen
    if (results$outcome[t] > 1) {
      results$vout[[t]] <- win * rbinom(l, 1, 1 - noise)
    } else {
      results$vout[[t]] <- loss * rbinom(l, 1, 1 - noise)
    }
    
    # Similarity
    results$win_s[t] <- sim$match_s(unlist(results$vout[t]), win)
    
    # Match with win IF similarity > .5
    results$left_s[t] <- ifelse(results$win_s[t] > c, sim$match_s(unlist(results$vopt[t]), left), 0)
    results$right_s[t] <- ifelse(results$win_s[t] > c, sim$match_s(unlist(results$vopt[t]), right), 0)
    
    # Update total number of traces > .5
    results$win_k[t] <- ifelse(results$win_s[t] > c, 1, 0) + results$win_k[t - 1]
    
    # Intensity: cubed similarity divided by number of traces
    results$left[t] <- results$left_s[t] ^ 3
    results$right[t] <- results$right_s[t] ^ 3
    
    # cumsum is equivalent to I (formula 3)
    results$cumleft[t] <- results$left[t] + results$cumleft[t - 1]
    results$cumright[t] <- results$right[t] + results$cumright[t - 1]
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  results
}

sim$mdm_main_freq <- function(noise, nTrial, outcomeprob, initevidence, subject, l, e) {
  # define ideal vectors
  left <- sample(c(rep(c(-1, 0, 1), l / 3), rep(1, l %% 3)))
  change <- left + sample(c(rep(1, 2), rep(0, l - 2)))
  right <- ifelse(change == 2, -1, change)
  
  win <- sample(c(rep(c(-1, 0, 1), l / 3), rep(1, l %% 3)))
  change <- win + sample(c(rep(1, 5), rep(0, l - 5)))
  loss <- ifelse(change == 2, -1, change)
  
  # intensity criterion
  c <- .5
  
  # Matrix with outcomes
  outcomes_left <- rbinom(nTrial, 1, outcomeprob)
  outcomes_right <- rbinom(nTrial, 1, outcomeprob)
  
  # Initial evidence
  ninev <- sum(initevidence)
  
  # Init options
  inev_opt <- matrix(c(rep(left, initevidence[1]),
                       rep(left, initevidence[2]),
                       rep(right, initevidence[3]),
                       rep(right, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise)))
  
  # Init outcomes
  inev_out <- matrix(c(rep(win, initevidence[1]),
                       rep(loss, initevidence[2]),
                       rep(win, initevidence[3]),
                       rep(loss, initevidence[4])),
                     nrow = ninev, byrow = TRUE) %>%
    data.frame() %>%
    mutate(trial = 1:n()) %>%
    split(.$trial) %>%
    map(~select(.x, -trial)) %>%
    map(~unlist(.x)) %>%
    map(~unname(.x)) %>%
    map(~.x * rbinom(l, 1, (1 - noise)))
  
  # Create dataframe
  results <- tibble(
    choice = c(rep(-1, sum(initevidence[1:2])),
               rep(1, sum(initevidence[3:4]))),
    outcome = c(rep(1, initevidence[1]),
                rep(0, initevidence[2]),
                rep(1, initevidence[3]),
                rep(0, initevidence[4]))
  ) %>%
    # (V)ector for option and outcome
    mutate(vopt = inev_opt,
           vout = inev_out)
  results <- results[sample(nrow(results)),] %>%
    mutate(trial = 1:n())
  results <- results %>%
    # Similarity
    mutate(win_s = 0,
           loss_s = map_dbl(vout, ~sim$match_s(unlist(.x), loss))) %>%
    # Match with options IF similarity > .5
    mutate(left_s = ifelse(loss_s >= c, map_dbl(vopt, ~sim$match_s(unlist(.x), left)), 0),
           right_s = ifelse(loss_s >= c, map_dbl(vopt, ~sim$match_s(unlist(.x), right)), 0)) %>%
    # Determine number of traces > .5
    mutate(win_k = ifelse(win_s > c, 1, 0)) %>%
    mutate(win_k = cumsum(win_k)) %>%
    # Intensity: cubed similarity
    mutate(left = left_s ^ 3,
           right = right_s ^ 3) %>%
    # cumsum is equivalent to I (formula 3)
    mutate(cumleft = cumsum(left),
           cumright = cumsum(right)) %>%
    mutate(cumleft = -cumleft,
           cumright = -cumright)
  
  if (results$win_k[nrow(results)] == 0) {
    results$win_k[nrow(results)] <- 1
  }
  
  # Initialize remaining trials
  init <- tibble(trial = (1:nTrial) + ninev)
  results <- bind_rows(results, init)
  
  # Simulation
  for (t in (1 + ninev):(nTrial + ninev)) {
    # Option chosen
    if (results$cumleft[t - 1] / results$win_k[t - 1] > results$cumright[t - 1] / results$win_k[t - 1]) {
      results$choice[t] <- -1
      results$vopt[[t]] <- left * rbinom(l, 1, 1 - noise)
      results$outcome[t] <-  outcomes_left[t - ninev]
    } else if (results$cumleft[t - 1] < results$cumright[t - 1]) {
      results$choice[t] <- 1
      results$vopt[[t]] <- right * rbinom(l, 1, 1 - noise)
      results$outcome[t] <-  outcomes_right[t - ninev]
    } else {
      results$choice[t] <- ifelse(rbinom(1, 1, .5) == 1, 1, -1)
      results$vopt[[t]] <- ifelse(results$choice[t] < 0,
                                  left * rbinom(l, 1, 1 - noise),
                                  right * rbinom(l, 1, 1 - noise))
      results$outcome[t] <-  outcomes_right[t - ninev]
    }
    
    # Outcome chosen
    if (results$outcome[t] > 1) {
      results$vout[[t]] <- win * rbinom(l, 1, 1 - noise)
    } else {
      results$vout[[t]] <- loss * rbinom(l, 1, 1 - noise)
    }
    
    # Similarity
    results$win_s[t] <- sim$match_s(unlist(results$vout[t]), win)
    
    # Match with win IF similarity > .5
    results$left_s[t] <- ifelse(results$win_s[t] > c, sim$match_s(unlist(results$vopt[t]), left), 0)
    results$right_s[t] <- ifelse(results$win_s[t] > c, sim$match_s(unlist(results$vopt[t]), right), 0)
    
    # Update total number of traces > .5
    results$win_k[t] <- ifelse(results$win_s[t] > c, 1, 0) + results$win_k[t - 1]
    
    # Intensity: cubed similarity divided by number of traces
    results$left[t] <- results$left_s[t] ^ 3
    results$right[t] <- results$right_s[t] ^ 3
    
    # cumsum is equivalent to I (formula 3)
    results$cumleft[t] <- results$left[t] + results$cumleft[t - 1]
    results$cumright[t] <- results$right[t] + results$cumright[t - 1]
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  results
}


sim$match_s <- function(prompt, colmn) {
  # Determine non-empty instances
  prompt_values <- which(prompt != 0)
  colmn_values <- which(colmn != 0)
  total <- c(prompt_values, colmn_values)
  # Shared non-empty instances
  possible_matches <- total[duplicated(total)]
  
  # Total non-zero matches (non-zero on both vectors)
  matches <- sum(prompt[possible_matches] == colmn[possible_matches])
  
  # Total possible matches (non-zero on either vector)
  matches / length(unique(total)) # s
}

# Simulation handler
mdm_sim <- function(n = 100,
                    noise = .33,
                    nTrial = 84,
                    outcomeprob = .75,
                    initevidence = c(9, 3, 3, 1),
                    l = 9,
                    prompt = "win") {
  # Set progres bar
  m <- n * (nTrial + sum(initevidence))
  assign("pb",
         txtProgressBar(min = 0, max = m, style = 3),
         envir = .GlobalEnv)
  
  # Run per participant
  if (prompt == "win") {
    pout <- map(1:n, ~sim$mdm_main(noise = noise,
                                   nTrial = nTrial,
                                   outcomeprob = outcomeprob,
                                   initevidence =  initevidence,
                                   subject =  .x,
                                   l = l))
  } else if (prompt == "loss") {
    pout <- map(1:n, ~sim$mdm_main_loss(noise = noise,
                                        nTrial = nTrial,
                                        outcomeprob = outcomeprob,
                                        initevidence =  initevidence,
                                        subject =  .x,
                                        l = l))
  } else { # frequent
    pout <- map(1:n, ~sim$mdm_main_freq(noise = noise,
                                        nTrial = nTrial,
                                        outcomeprob = outcomeprob,
                                        initevidence =  initevidence,
                                        subject =  .x,
                                        l = l))
  }
  
  # Adjust choiceindex
  pout <- map(pout, ~mutate(.x, choiceindex = ifelse(choice == 1, 0, 1)))
  # Return
  pout
}

# Summarizes results
mdm_sumdata <- function(input, participant = NA) {
  if (is.na(participant)) {
    # All participants
    data.frame(
      map(input, "choice") %>%
        as.data.frame() %>%
        transmute(choice = rowMeans(.)),
      map(input, "choiceindex") %>%
        as.data.frame() %>%
        transmute(choiceindex = rowMeans(.)),
      map(input, "cumleft") %>%
        as.data.frame() %>%
        transmute(cumleft = rowMeans(.)),
      map(input, "cumright") %>%
        as.data.frame() %>%
        transmute(cumright = rowMeans(.))
    ) %>%
      mutate(trial = 1:n())
  } else {
    # Individual participant
    input[[participant]] %>%
      mutate(trial = 1:n())
  }
}

### Rescorla-Wagner----
# Main simulation
sim$rw_main <- function(simpars,
                    subject,
                    nTrial = 84,
                    initevidence,
                    outcomeprob) {
  # Get alpha and beta parameters
  alpha <- simpars[1]
  beta <- simpars[2]
  # Length of initial evidence
  ninev <- sum(initevidence)
  
  # Init expectations
  v <- rep(.5, 2)
  
  # # initiate output matrices
  # VV <- list(matrix(nrow = n,
  #                   ncol = nTrial),
  #            matrix(nrow = n,
  #                   ncol = nTrial))
  # PP <- matrix(nrow = n,
  #              ncol = nTrial)
  
  # Initial evidence
  nleft <- sum(initevidence[c(1, 2)])
  nright <- sum(initevidence[c(3, 4)])
  inev <- tibble(choice = c(rep(1, nleft),
                            rep(2, nright)),
                 outcome = c(rep(1, initevidence[1]),
                             rep(0, initevidence[2]),
                             rep(1, initevidence[3]),
                             rep(0, initevidence[4])))
  inev <- inev[sample(nrow(inev)),]
  
  # get the task information
  outcome <- data.frame(left = rbinom(nTrial, 1, outcomeprob),
                        right = rbinom(nTrial, 1, outcomeprob))
  nt <- nTrial + ninev
  nc <- 2
  
  # initialise choice and outcome vectors to store the data.
  loglik <- 0
  choice <- rep(NA, nt)
  VV <- matrix(nrow = nt,
               ncol = nc) # matrix to store value over trials
  PP <- matrix(nrow = nt,
               ncol = nc) # matrix to store choice probability over trials
  
  # Initial evidence
  for (t in 1:nrow(inev)) {
    # Compute likelihood of the each choice option 
    # exponentiate the value
    ev <- exp(beta * v)
    # compute the sum of the values
    sev <- sum(ev)
    # probability each choice i.e. ratio of each of the values and their sum. 
    # This code effectively does: 
    # p(1) = ev(1)/sev;
    # p(2) = ev(2)/sev;
    p <- ev/sev
    
    c <- unlist(inev[t, 1])
    r <- unlist(inev[t, 2])
    
    loglik <- loglik + log(p[c])
    
    # store value of V
    VV[t,] <- v
    PP[t,] <- p
    
    # compute prediction error
    dv <- r - v[c]
    # update value
    v[c] <- v[c] + alpha * dv
    
    # store choice
    choice[t] <- c
    
  }
  
  # Free sampling
  for (t in (ninev + 1):nt) {
    # Compute likelihood of the each choice option 
    # exponentiate the value
    ev <- exp(beta * v)
    # compute the sum of the values
    sev <- sum(ev)
    # probability each choice i.e. ratio of each of the values and their sum. 
    # This code effectively does: 
    # p(1) = ev(1)/sev;
    # p(2) = ev(2)/sev;
    p <- ev/sev
    
    # Do a weighted coinflip to make a choice: choose stim 1 if random
    # number is in the [0 p(1)] interval, and 2 otherwise
    if (runif(1) < p[1]) {
      c <- 1
    } else {
      c <- 2
    }
    # select the outcome for this choice
    r <- outcome[t - ninev, c]
    
    # update the log likelihood with the p(choice|model):
    # note that this line can be done more efficiently after the trial
    # loop, see below
    # alternative, more efficient way of computing the likelihood
    # loglik = sum(log(PP(c1,1)))+sum(log(PP(c2,2)));
    loglik <- loglik + log(p[c])
    
    # store value of V
    VV[t,] <- v
    PP[t,] <- p
    
    # compute prediction error
    dv <- r - v[c]
    # update value
    v[c] <- v[c] + alpha * dv
    
    # store choice
    choice[t] <- c
    
    # Update counter
    i <- (subject - 1) * (nTrial + ninev) + t
    setTxtProgressBar(pb, i)
  }
  
  # Return
  data.frame(choice,
             value_left = VV[,1],
             value_right = VV[,2],
             choiceprob_left = PP[,1],
             choiceprob_right = PP[,2],
             outprob = rep(outcomeprob, nt)) %>%
    mutate(trial = 1:n())
}

# Simulation handler
rw_sim <- function(n = 100,
                   alpha = .25,
                   beta = 1,
                   nTrial = 84,
                   initevidence = c(9, 3 , 3, 1),
                   outcomeprob = .75) {
  # Set progres bar
  m <- n * (nTrial + sum(initevidence))
  assign("pb",
         txtProgressBar(min = 0, max = m, style = 3),
         envir = .GlobalEnv)
  
  # Get input
  subjects <- 1:n
  simpars <- c(alpha, beta)
  names(simpars) <- c("alpha", "beta")
  
  # Run per participant
  pout <- map(subjects, ~sim$rw_main(simpars, .x, nTrial, initevidence, outcomeprob))
  # Adjust choiceindex
  pout <- map(pout, ~mutate(.x, choiceindex = ifelse(choice == 2, 0, 1)))
  # Return
  pout
}

# Summarizes results
rw_sumdata <- function(input, participant = NA) {
  if (is.na(participant)) {
    # All participants
    data.frame(
      map(input, "choice") %>%
        as.data.frame() %>%
        transmute(choice = rowMeans(.)),
      map(input, "choiceindex") %>%
        as.data.frame() %>%
        transmute(choiceindex = rowMeans(.)),
      map(input, "value_left") %>%
        as.data.frame() %>%
        transmute(value_left = rowMeans(.)),
      map(input, "value_right") %>%
        as.data.frame() %>%
        transmute(value_right = rowMeans(.)),
      map(input, "choiceprob_left") %>%
        as.data.frame() %>%
        transmute(choiceprob_left = rowMeans(.)),
      map(input, "choiceprob_right") %>%
        as.data.frame() %>%
        transmute(choiceprob_right = rowMeans(.)),
      map(input, "outprob") %>%
        as.data.frame() %>%
        transmute(outprob = rowMeans(.)),
      map(input, "trial") %>%
        as.data.frame() %>%
        transmute(trial = rowMeans(.))
    ) %>%
      pivot_longer(cols = c(value_left, value_right),
                   names_to = "bandit",
                   values_to = "value")
  } else {
    # Individual participant
    input[[participant]] %>%
      mutate(trial = 1:n()) %>%
      pivot_longer(cols = c(value_left, value_right),
                   names_to = "bandit",
                   values_to = "value")
  }
}

### General graph wrapper----
draw <- function(rich, imp, x = FALSE, y = NA, l = FALSE, t = NA) {
  g <- bind_rows(rich %>%
                   mutate(condition = "rich"),
                 imp %>%
                   mutate(condition = "impoverished")) %>%
    mutate(condition = factor(condition, levels = c("rich", "impoverished"))) %>%
    ggplot() +
    geom_line(aes(x = trial, y = choiceindex, color = condition)) +
    geom_hline(aes(yintercept = .5), linetype = 3) +
    scale_color_brewer(palette = "Dark2") +
    ylim(0, 1) +
    theme_apa() + 
    theme(legend.position = c(.7, .8),
          legend.justification = c("center")) +
    labs(y = "Percentage sampling frequent option")
  
  # No x axis
  if (!x) {
    g <- g + theme(axis.title.x = element_blank())
  }
  
  # No y axis
  if (is.na(y)) {
    g <- g + theme(axis.title.y = element_blank())
  } else {
    g <- g + labs(y = y)
  }
  
  # No legend
  if (!l) {
    g <- g + theme(legend.position = "none")
  }
  
  # Title
  if (!is.na(t)) {
    g <- g + labs(title = t)
  }
  
  # Return
  g
}


# Simulations -------------------------------------------------------------

n <- 10000 # Iterations to be run
results <- new.env() # Environment for results

# BAYESIAN
results$bayes_rich_RE <- bayes_sim(n = n, initevidence = c(3, 0, 0, 1), outcomeprob = .75, q = 3) %>% bayes_sumdata()
results$bayes_imp_RE  <- bayes_sim(n = n, initevidence = c(0, 3, 1, 0), outcomeprob = .25, q = 3) %>% bayes_sumdata()
draw(results$bayes_rich_RE, results$bayes_imp_RE)

results$bayes_rich_PC <- bayes_sim(n = n, initevidence = c(9, 3, 3, 1), outcomeprob = .75, q = 3) %>% bayes_sumdata()
results$bayes_imp_PC  <- bayes_sim(n = n, initevidence = c(3, 9, 1, 3), outcomeprob = .25, q = 3) %>% bayes_sumdata()
draw(results$bayes_rich_PC, results$bayes_imp_PC)
# ggsave("Output/Graphs/sim_bayes.svg", device = "svg")

# results$bayes_r4   <- bayes_sim(n = n, initevidence = c(4, 4, 4, 4), outcomeprob = .75) %>% bayes_sumdata()
# results$bayes_i4   <- bayes_sim(n = n, initevidence = c(4, 4, 4, 4), outcomeprob = .25) %>% bayes_sumdata()
# draw(results$bayes_r4, results$bayes_i4)
# # ggsave("Output/Graphs/sim_bayes_4s.svg", device = "svg")
# 
# results$bayes_r50  <- bayes_sim(n = n, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% bayes_sumdata()
# results$bayes_i50  <- bayes_sim(n = n, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% bayes_sumdata()
# draw(results$bayes_r50, results$bayes_i50)
# # ggsave("Output/Graphs/sim_bayes_50.svg", device = "svg")

# BIAS
results$bias_rich_RE <- bias_sim(n = n, initevidence = c(3, 0, 0, 1), outcomeprob = .75) %>% bias_sumdata()
results$bias_imp_RE  <- bias_sim(n = n, initevidence = c(0, 3, 1, 0), outcomeprob = .25) %>% bias_sumdata()
draw(results$bias_rich_RE, results$bias_imp_RE)

results$bias_rich_PC <- bias_sim(n = n, initevidence = c(9, 3, 3, 1), outcomeprob = .75) %>% bias_sumdata()
results$bias_imp_PC  <- bias_sim(n = n, initevidence = c(3, 9, 1, 3), outcomeprob = .25) %>% bias_sumdata()
draw(results$bias_rich_PC, results$bias_imp_PC)
# ggsave("Output/Graphs/sim_bias.svg", device = "svg")

# results$bias_r4   <- bias_sim(n = n, initevidence = c(4, 4, 4, 4), outcomeprob = .75) %>% bias_sumdata()
# results$bias_i4   <- bias_sim(n = n, initevidence = c(4, 4, 4, 4), outcomeprob = .25) %>% bias_sumdata()
# draw(results$bias_r4, results$bias_i4)
# # ggsave("Output/Graphs/sim_bias_4s.svg", device = "svg")
# 
# results$bias_r50  <- bias_sim(n = n, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% bias_sumdata()
# results$bias_i50  <- bias_sim(n = n, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% bias_sumdata()
# draw(results$bias_r50, results$bias_i50)
# # ggsave("Output/Graphs/sim_bias_50.svg", device = "svg")

# Rescorla-Wagner
results$rw_rich_RE <- rw_sim(n = n, initevidence = c(3, 0, 0, 1), outcomeprob = .75) %>% rw_sumdata()
results$rw_imp_RE  <- rw_sim(n = n, initevidence = c(0, 3, 1, 0), outcomeprob = .25) %>% rw_sumdata()
draw(results$rw_rich_RE, results$rw_imp_RE)

results$rw_rich_PC <- rw_sim(n = n, initevidence = c(9, 3, 3, 1), outcomeprob = .75) %>% rw_sumdata()
results$rw_imp_PC  <- rw_sim(n = n, initevidence = c(3, 9, 1, 3), outcomeprob = .25) %>% rw_sumdata()
draw(results$rw_rich_PC, results$rw_imp_PC)
# ggsave("Output/Graphs/sim_rw.svg", device = "svg")

# results$rw_r4   <- rw_sim(n = n, initevidence = c(4, 4, 4, 4), outcomeprob = .75) %>% rw_sumdata()
# results$rw_i4   <- rw_sim(n = n, initevidence = c(4, 4, 4, 4), outcomeprob = .25) %>% rw_sumdata()
# draw(results$rw_r4, results$rw_i4)
# # ggsave("Output/Graphs/sim_rw_4s.svg", device = "svg")
# 
# results$rw_r50  <- rw_sim(n = n, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% rw_sumdata()
# results$rw_i50  <- rw_sim(n = n, initevidence = c(6, 6, 2, 2), outcomeprob = .5) %>% rw_sumdata()
# draw(results$rw_r50, results$rw_i50)
# # ggsave("Output/Graphs/sim_rw_50.svg", device = "svg")


# Grid graph -------------------------------------------------------------
p <- grid.arrange(draw(results$bias_rich_REf, results$bias_imp_REf, y = "Perfect contingency [4 trials]", t = "BIAS"),
                  draw(results$bayes_rich_RE, results$bayes_imp_RE, t = "Bayesian"),
                  draw(results$rw_rich_RE, results$rw_imp_RE, l = T, t = "Rescorla-Wagner"),
                  draw(results$bias_rich_PCf, results$bias_imp_PCf, x = T, y = "Zero contingency [16 trials]"),
                  draw(results$bayes_rich_PC, results$bayes_imp_PC, x = T),
                  draw(results$rw_rich_PC, results$rw_imp_PC, x = T),
                  nrow = 2,
                  left = "Percentage sampling frequent option")

# Two rows, top with real bottom with PC evidence
ggsave(plot = p,
       filename = "Output/Graphs/sim_overview_win_prompt_10000.svg",
       device = "svg",
       width = 30,
       height = 15,
       units = "cm")

