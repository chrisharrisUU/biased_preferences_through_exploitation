### Oscillation between options
switching <- function(.data, from) {
  if (from < 10) {
    .data %<>%
      mutate(switching = ifelse((primacy == "A" & week5 == 1) | (primacy == "B" & week5 == -1), 1, 0))
  } else {
    .data %<>%
      mutate(switching = ifelse((primacy == "A" & week17 == 1) | (primacy == "B" & week17 == -1), 1, 0))
  }
  for (i in (from + 1):100) {
    .data$switching <- .data$switching + switching.function(i, .data)
  }
  rm(i)
  return(.data)
}

# The switching function for detecting oscillations
switching.function <- function(laterweek, df) {
  k <- which(colnames(df) == paste("week", laterweek, sep = ""))
  j <- k - 1
  switches <- rep(0, nrow(df))
  switches[which(df[,j] != df[,k])] <- 1
  return(switches)
}

# Oscillations as timeseries
oscillations <- function(.data) {
  # Range
  weeks <- colnames(.data) %>%
    .[grep("week", .)] %>%
    substr(., 5, nchar(.)) %>%
    as.integer(.)
  from <- min(weeks)
  from2 <- from + 1
  to <- max(weeks)
  # First trial
  first <- .data %>%
    select(primacy,
           first = paste0("week", from)) %>%
    mutate(firstswitch = ifelse((primacy == "A" & first == 1) | (primacy == "B" & first == -1), 1, 0)) %>%
    select(firstswitch) %>%
    unlist
  
  # Remaining trials
  condition <- .data$condition
  
  x <- map_dfc(from2:to, switching.function, .data) %>%
    # Include condition
    mutate(condition = condition) %>%
    # Include first week
    mutate(!!paste0("V", 0) := first) %>%
    # Grouping
    group_by(condition) %>%
    # Summarize percentage positive hits
    summarize_at(.vars = vars(contains("V")),
                 .funs = funs(mean(., na.rm = TRUE)))
  
  # Rename trials
  colnames(x) <- c("condition",
                   paste0("week", from2:to),
                   paste0("week", from))
  # Rearrange to long format
  x %>%
    # Long format
    gather(key = time,
           value = oscillation,
           paste0("week", from:to)) %>%
    # As integer for time series graph
    mutate(time = as.integer(substr(time, 5, nchar(time))))
}

# Graph with overlaying rectangles
drawgraph <- function(df, a = 0.01) {
  df %>%
    ggplot(aes(x = x,
               y = y,
               color = x)) +
    geom_point(alpha = a, shape = 15, size = 20) +
    geom_hline(yintercept = 0, color = "grey") +
    theme_apa() +
    guides(color = "none", fill = "none", alpha = "none") +
    scale_color_brewer(palette = "Dark2") +
    scale_alpha(range = c(.001, .1)) +
    geom_rect(aes(xmin = 1 - 0.14,
                  xmax = 1 + 0.14,
                  ymin = 0,
                  ymax = mean(unlist(df[df$x == "rich","y"]))),
              fill = NA,
              color = "black") +
    geom_rect(aes(xmin = 2 - 0.14,
                  xmax = 2 + 0.14,
                  ymin = 0,
                  ymax = mean(unlist(df[df$x == "impoverished","y"]))),
              fill = NA,
              color = "black") +
    labs(x = "Condition",
         y = "Frequency",
         title = "Spread of sampling biases") +
    coord_flip()
}

# Time series functions
# Data prep: Counterbalance, long format
prep <- function(x) {
  # Range
  weeks <- colnames(x) %>%
    .[grep("week", .)] %>%
    substr(., 5, nchar(.)) %>%
    as.integer(.)
  from <- min(weeks)
  to <- max(weeks)
  if (from > 10) {expname <- "Exp 2 - Pseudocontingency"} else {expname <- "Exp 1 - Real contingency"}
  x %>%
    select(participant.id, condition, primacy, contains("week")) %>%
    # Counterbalancing
    mutate_at(.vars = vars(contains("week")),
              .funs = funs(ifelse(primacy == "A", . * (-1), .))) %>%
    # # Dominant
    # mutate_at(.vars = vars(contains("week")),
    #           .funs = funs(ifelse(condition == "rich", ., . * (-1)))) %>%
    # 0 - 1 for percentages
    mutate_at(.vars = vars(contains("week")),
              .funs = funs(ifelse(. < 0, 0, 1))) %>%
    group_by(condition) %>%
    # Summarize percentage positive hits
    summarize_at(.vars = vars(contains("week")),
                 .funs = funs(mean(., na.rm = TRUE))) %>%
    # Long format
    gather(key = time,
           value = sampling,
           paste0("week", from:to)) %>%
    # As integer for time series graph
    mutate(time = as.integer(substr(time, 5, nchar(time))),
           exp = expname)
}

time_series <- function(df) {
  # Range
  weeks <- colnames(df) %>%
    .[grep("week", .)] %>%
    substr(., 5, nchar(.)) %>%
    as.integer(.)
  from <- min(weeks)
  to <- max(weeks)
  
  # Data prep
  data <- prep(df)
  
  # Create graph
  ggplot(data,
         aes(x = time,
             y = sampling,
             color = condition)) +
    # geom_hline(yintercept = .5,
    #                alpha = .3) +
    geom_segment(aes(x = 5,
                     xend = 100,
                     y = .5,
                     yend = .5),
                 color = "#999999",
                 size = .1) +
    geom_point(size = .9) +
    geom_line(size = .2,
              alpha = .3) +
    geom_smooth(method = "loess",
                span = 1,
                size = 1) +
    scale_color_brewer(palette = "Dark2") +
    theme_apa() +
    labs(y = "Percentage sampling frequent option",
         x = "Trial")
}

# Import functions from GitHub
# https://stackoverflow.com/a/35720824/10357426
source_https <- function(u, unlink.tmp.certs = FALSE) {
  # load package
  if (!require(RCurl)) {install.packages("RCurl"); library(RCurl)}
  
  # read script lines from website using a security certificate
  if (!file.exists(here("Auxiliary/cacert.pem"))) {
    download.file(url = "http://curl.haxx.se/ca/cacert.pem", destfile = here("Auxiliary/cacert.pem"))
  }
  script <- getURL(u, followlocation = TRUE, cainfo = here("Auxiliary/cacert.pem"))
  if (unlink.tmp.certs) {unlink(here("Auxiliary/cacert.pem"))}
  
  # parase lines and evealuate in the global environement
  eval(parse(text = script), envir = .GlobalEnv)
}

# My functions for outputting inference tests in APAish style
source_https("https://raw.githubusercontent.com/chrisharrisUU/testoutputs/master/functions.R")

# Goallab function for calculating error bars for within and between factor designs
source_https("https://raw.githubusercontent.com/Goallab/WithinS_CI/master/WithinS_CI.R")